<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>単語抽選アプリ</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
            display: flex;
            justify-content: center;
            background: #f9f9f9;
        }

        #main {
            width: 800px;
            /* 600px -> 800px レイアウト拡張に対応 */
        }

        .group {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 6px;
            background: #fff;
            transition: background 0.2s, opacity 0.2s;
        }

        .group.disabled {
            background: #f4f4f4;
            /* 少し薄く */
            color: #888;
            /* フォント色を薄く */
        }

        .group.disabled input[type="checkbox"] {
            filter: grayscale(0.8) brightness(1.2);
            /* 彩度を下げ明度を上げる */
        }

        .group.disabled input[type="text"],
        .group.disabled input[type="number"],
        .group.disabled textarea,
        .group.disabled button {
            color: #888;
            /* border-color変更を削除して、デフォルトスタイル(影など)を維持 */
        }

        .group.disabled .group-exec-prob {
            color: #b88;
            /* 実行確率もグレー寄りの赤に */
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            gap: 4px;
        }

        .details {
            margin-left: 10px;
        }

        .columns {
            display: flex;
            gap: 6px;
        }

        .left,
        .right {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .column-label {
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 2px;
        }

        .column-label-left,
        .word-line-left {
            width: 22em;
            /* 14em -> 22em 確率表示文をさらに広げる */
            text-align: left;
            padding-right: 6px;
        }

        .column-label-right,
        .word-line-right {
            /* width: calc(30ch - 50px - 4px); */
            /* ボタンが増えるので幅固定を解除 */
            display: flex;
            align-items: center;
        }

        .word-line-right:has(button) {
            /* width: 30ch; */
        }

        .word-line {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .word-line input[type="number"] {
            width: 4em;
            height: 28px;
            box-sizing: border-box;
        }

        .prob-span {
            margin-left: 6px;
            font-size: 0.9em;
            color: #666;
            width: auto;
            /* 幅固定を解除 */
            text-align: right;
            display: inline-block;
        }

        .prob-total {
            font-size: 0.85em;
            color: #888;
            margin-left: 2px;
        }

        .group-exec-prob {
            font-size: 0.9em;
            color: #d33;
            margin-left: 10px;
            font-weight: bold;
        }

        .trigger-area {
            width: 90%;
            height: auto;
            min-height: 2.4em;
            /* 2行分くらい確保するか、1行なら1.5em */
            font-family: inherit;
            resize: none;
            overflow-y: hidden;
            box-sizing: border-box;
            padding: 4px;
            vertical-align: middle;
        }

        .word-line input[type="text"] {
            height: 28px;
            box-sizing: border-box;
        }

        .word-line button {
            /* width: 50px; 固定幅を廃止 */
            min-width: 30px;
            padding: 0 4px;
            height: 28px;
        }

        .bottom {
            margin-top: 6px;
        }

        .result-line {
            display: flex;
            padding-left: 0.25em;
        }

        .result-name {
            width: 12em;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            font-weight: bold;
        }

        .result-word {
            margin-left: 0.5em;
        }

        #results {
            margin-top: 15px;
            font-size: 1.2em;
            white-space: pre;
        }

        input[type="text"] {
            width: 30ch;
        }

        button {
            margin-left: 2px;
        }
    </style>
</head>

<body>
    <div id="main">
        <button onclick="draw()">抽選</button>
        <button onclick="searchGoogle()">Googleで検索</button>
        <div id="results"></div>

        <div style="margin:10px 0;">
            <input type="text" id="settingsName" placeholder="設定名を入力" style="width:30ch; margin-bottom:5px;"
                oninput="saveSettings()">
            <button onclick="exportSettings()">設定をエクスポート</button>
            <input type="file" id="importFile" style="display:none" onchange="importSettings(event)">
            <button onclick="document.getElementById('importFile').click()">設定をインポート</button>
            <button onclick="resetSettings()">設定をリセット</button>
        </div>

        <div id="groups"></div>
        <button onclick="addGroup()">グループを追加</button>
    </div>

    <script>
        let groups = [];
        let recalculateTimer = null;

        function saveSettings() {
            const name = document.getElementById("settingsName").value;
            const data = { groups: groups, name: name };
            localStorage.setItem("wordGroups_" + location.pathname, JSON.stringify(data));
        }

        function loadSettings() {
            const dataStr = localStorage.getItem("wordGroups_" + location.pathname);
            if (dataStr) {
                try {
                    const data = JSON.parse(dataStr);
                    if (Array.isArray(data)) {
                        groups = data;
                    } else {
                        groups = data.groups || [];
                        const nameBox = document.getElementById("settingsName");
                        if (nameBox) nameBox.value = data.name || "";
                    }
                } catch (e) {
                    console.error("Load settings error:", e);
                    // Fallback default
                    groups = [{ name: "グループ1", words: [{ text: "", weight: 1 }], enabled: true, min: 0, max: 1, isSubgroup: false, triggers: "", search: true, collapsed: false }];
                }
            } else {
                groups = [{ name: "グループ1", words: [{ text: "", weight: 1 }], enabled: true, min: 0, max: 1, isSubgroup: false, triggers: "", search: true, collapsed: false }];
            }
        }

        function resetSettings() {
            if (confirm("本当にリセットしますか？")) {
                groups = [{ name: "グループ1", words: [{ text: "", weight: 1 }], enabled: true, min: 0, max: 1, isSubgroup: false, triggers: "", search: true, collapsed: false }];
                const nameBox = document.getElementById("settingsName");
                if (nameBox) nameBox.value = "";
                saveSettings();
                renderGroups();
            }
        }

        function triggerRecalculate() {
            if (recalculateTimer) clearTimeout(recalculateTimer);
            recalculateTimer = setTimeout(calculateAndRenderProbabilities, 50);
        }

        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        }

        function renderGroups() {
            const container = document.getElementById("groups");
            container.innerHTML = "";
            groups.forEach((g, i) => {
                const div = document.createElement("div"); div.className = "group" + (g.enabled ? "" : " disabled");

                // header
                const row1 = document.createElement("div"); row1.className = "header";
                row1.innerHTML = `
      <button onclick="toggleCollapse(${i})">${g.collapsed ? "▶" : "▼"}</button>
      <input type="text" value="${g.name}" onchange="groups[${i}].name=this.value; saveSettings();">
      <label><input type="checkbox" ${g.enabled ? "checked" : ""} onchange="groups[${i}].enabled=this.checked; saveSettings(); renderGroups(); triggerRecalculate();"> 有効</label>
      <label><input type="checkbox" ${g.search ? "checked" : ""} onchange="groups[${i}].search=this.checked; saveSettings();"> 検索</label>
      <button onclick="moveGroup(${i},-1)">↑</button>
      <button onclick="moveGroup(${i},1)">↓</button>
      <button onclick="deleteGroup(${i})">削除</button>
    `;
                div.appendChild(row1);

                // details
                const details = document.createElement("div"); details.className = "details";
                details.style.display = g.collapsed ? "none" : "block";

                // 抽選数
                const row2 = document.createElement("div");
                row2.innerHTML = `抽選数: <input type="number" min="0" value="${g.min || 0}" onchange="groups[${i}].min=parseInt(this.value)||0; saveSettings(); triggerRecalculate();"> ~ <input type="number" min="0" value="${g.max || 0}" onchange="groups[${i}].max=parseInt(this.value)||0; saveSettings(); triggerRecalculate();">`;
                details.appendChild(row2);

                // サブグループ
                const row3 = document.createElement("div");
                row3.innerHTML = `<label><input type="checkbox" ${g.isSubgroup ? "checked" : ""} onchange="toggleSubgroup(${i},this.checked)"> サブグループ</label>
                <span class="group-exec-prob" id="group-exec-prob-${i}"></span>`;
                details.appendChild(row3);

                if (g.isSubgroup) {
                    const trigger = document.createElement("div");
                    trigger.innerHTML = `<textarea class="trigger-area" placeholder="トリガー式\n(例) 単語A & 単語B, 単語C" rows="1"
                        oninput="groups[${i}].triggers=this.value; saveSettings(); triggerRecalculate(); autoResize(this);">${g.triggers || ""}</textarea>`;
                    details.appendChild(trigger);
                    // 初期リサイズ
                    setTimeout(() => {
                        const ta = trigger.querySelector("textarea");
                        if (ta) autoResize(ta);
                    }, 0);
                }

                // columns
                const columns = document.createElement("div"); columns.className = "columns";
                const leftCol = document.createElement("div"); leftCol.className = "left";
                const leftLabel = document.createElement("div"); leftLabel.className = "column-label-left column-label"; leftLabel.textContent = "選ばれやすさ";
                leftCol.appendChild(leftLabel);
                const rightCol = document.createElement("div"); rightCol.className = "right";
                const rightLabel = document.createElement("div"); rightLabel.className = "column-label-right column-label"; rightLabel.textContent = "抽選される単語リスト";
                rightCol.appendChild(rightLabel);

                g.words.forEach((w, j) => {
                    const leftLine = document.createElement("div"); leftLine.className = "word-line-left word-line";
                    const leftInput = document.createElement("input"); leftInput.type = "number"; leftInput.min = 1; leftInput.value = w.weight;
                    leftInput.onchange = () => {
                        groups[i].words[j].weight = parseInt(leftInput.value) || 1;
                        saveSettings();
                        triggerRecalculate();
                    };
                    leftLine.appendChild(leftInput);

                    const probSpan = document.createElement("span");
                    probSpan.className = "prob-span";
                    probSpan.id = `prob-${i}-${j}`;
                    probSpan.innerHTML = `-%<span class="prob-total"></span>`; // InnerHTML for sub-span
                    leftLine.appendChild(probSpan);

                    leftCol.appendChild(leftLine);

                    const rightLine = document.createElement("div"); rightLine.className = "word-line-right word-line";
                    const rightInput = document.createElement("input"); rightInput.type = "text"; rightInput.value = w.text;
                    rightInput.onchange = () => { groups[i].words[j].text = rightInput.value; saveSettings(); triggerRecalculate(); };
                    rightLine.appendChild(rightInput);

                    const upBtn = document.createElement("button"); upBtn.textContent = "↑"; upBtn.onclick = () => moveWord(i, j, -1); rightLine.appendChild(upBtn);
                    const downBtn = document.createElement("button"); downBtn.textContent = "↓"; downBtn.onclick = () => moveWord(i, j, 1); rightLine.appendChild(downBtn);

                    if (j > 0) { const delBtn = document.createElement("button"); delBtn.textContent = "削除"; delBtn.onclick = () => { deleteWord(i, j); }; rightLine.appendChild(delBtn); }
                    rightCol.appendChild(rightLine);
                });

                columns.appendChild(leftCol);
                columns.appendChild(rightCol);
                details.appendChild(columns);

                // add button
                const addDiv = document.createElement("div"); addDiv.className = "bottom";
                const addBtn = document.createElement("button"); addBtn.textContent = "単語を追加"; addBtn.onclick = () => { groups[i].words.push({ text: "", weight: 1 }); saveSettings(); renderGroups(); };
                addDiv.appendChild(addBtn);
                details.appendChild(addDiv);

                div.appendChild(details);
                container.appendChild(div);

                // 初回描画時に計算
                triggerRecalculate();
            });
        }

        function calculateAndRenderProbabilities() {
            // 解析的近似計算 (Analytical Approximation)
            // 1. 各グループごとの単語当選確率 (条件付き) を計算
            // 2. 固定点反復法でグループ実行確率と単語全体確率を収束させる

            // Stats containers
            const groupExecProbs = new Array(groups.length).fill(0); // P(Group executes)
            const wordInGroupProbs = groups.map(() => []); // P(Word is chosen | Group executes)

            // Step 1: Initialize & Pre-calculate conditional probabilities
            groups.forEach((g, i) => {
                const totalWeight = g.words.reduce((sum, w) => sum + (parseInt(w.weight) || 0), 0);
                const avgCount = ((g.min || 0) + (g.max || 0)) / 2;

                g.words.forEach((w, j) => {
                    let p = 0;
                    if (totalWeight > 0) {
                        // 近似: (重み/全体) * 抽選回数。ただし100%を超えない。
                        // 非復元抽出の厳密計算は複雑すぎるため、期待値ベースで近似する
                        p = Math.min(1.0, ((parseInt(w.weight) || 0) / totalWeight) * avgCount);
                    }
                    wordInGroupProbs[i].push(p);

                    // 単純なグループ内確率表示 (UI更新)
                    const span = document.getElementById(`prob-${i}-${j}`);
                    if (span) {
                        // 既存のHTML構造を維持しつつ更新
                        const probPct = totalWeight > 0 ? (((parseInt(w.weight) || 0) / totalWeight) * 100).toFixed(1) : "-";
                        // 後で全体確率を追加するために一旦セット
                        span.setAttribute("data-local-prob", probPct);
                    }
                });

                if (g.enabled && !g.isSubgroup) {
                    groupExecProbs[i] = 1.0; // 通常グループは常に実行される(とみなす)
                } else if (!g.enabled) {
                    groupExecProbs[i] = 0.0;
                }
            });

            // Step 2: Fixed Point Iteration
            // 依存関係（ある単語が選ばれる -> トリガーが引かれる -> サブグループ実行 -> 別の単語が選ばれる）
            // を解決するため、数回ループさせる
            let currentTotalWordProbs = {}; // Word Text -> Probability(0.0~1.0)

            for (let iter = 0; iter < 5; iter++) {
                // 2-a. Calculate Total Word Probabilities based on current Group Exec Probs
                const tempWordProbs = {};

                groups.forEach((g, i) => {
                    const execP = groupExecProbs[i];
                    if (execP <= 0) return;

                    g.words.forEach((w, j) => {
                        const condP = wordInGroupProbs[i][j];
                        const actualP = execP * condP;
                        if (actualP > 0) {
                            const txt = w.text; // Note: case sensitive exact match
                            // 和事象 P(A or B) = 1 - (1-P(A))*(1-P(B))
                            const oldP = tempWordProbs[txt] || 0;
                            tempWordProbs[txt] = 1 - (1 - oldP) * (1 - actualP);
                        }
                    });
                });
                currentTotalWordProbs = tempWordProbs;

                // 2-b. Update Subgroup Execution Probabilities based on Triggers
                let changed = false;
                groups.forEach((g, i) => {
                    if (!g.enabled || !g.isSubgroup) return;

                    let execP = 0;
                    if (g.triggers) {
                        try {
                            const ast = parseExpr(g.triggers);
                            execP = evalProb(ast, currentTotalWordProbs);
                        } catch (e) { /* ignore parse error in calc */ }
                    }

                    if (Math.abs(groupExecProbs[i] - execP) > 0.001) {
                        groupExecProbs[i] = execP;
                        changed = true;
                    }
                });

                if (!changed) break; // Converged
            }

            // Step 3: Render to UI
            groups.forEach((g, i) => {
                // グループ実行確率
                const execSpan = document.getElementById(`group-exec-prob-${i}`);
                if (execSpan) {
                    if (g.enabled) {
                        const pct = (groupExecProbs[i] * 100).toFixed(1);
                        execSpan.textContent = `(実行確率: ${pct}%)`;
                    } else {
                        const pct = "0.0";
                        execSpan.textContent = `(実行確率: ${pct}%)`;
                    }
                }

                // 単語全体確率
                g.words.forEach((w, j) => {
                    const span = document.getElementById(`prob-${i}-${j}`);
                    if (span) {
                        const localProb = span.getAttribute("data-local-prob");
                        const totalProb = currentTotalWordProbs[w.text] || 0;
                        const totalProbPct = (totalProb * 100).toFixed(1);

                        // グループ確率はこれまで通り。横に全体確率を追加。
                        span.innerHTML = `${localProb}% <span class="prob-total">(${totalProbPct}%)</span>`;
                    }
                });
            });
        }

        function evalProb(node, probs) {
            if (!node) return 0;
            if (node.type === "WORD") return probs[node.value] || 0;
            if (node.type === "AND") {
                // P(A & B) assuming independence = P(A) * P(B)
                return node.children.reduce((acc, c) => acc * evalProb(c, probs), 1);
            }
            if (node.type === "OR") {
                // P(A | B) assuming independence = 1 - (1-P(A))*(1-P(B))
                return 1 - node.children.reduce((acc, c) => acc * (1 - evalProb(c, probs)), 1);
            }
            return 0;
        }

        function toggleCollapse(i) { groups[i].collapsed = !groups[i].collapsed; saveSettings(); renderGroups(); }
        function addGroup() { groups.push({ name: "新規グループ", words: [{ text: "", weight: 1 }], enabled: true, min: 0, max: 1, isSubgroup: false, triggers: "", search: true, collapsed: false }); saveSettings(); renderGroups(); }
        function deleteGroup(i) { groups.splice(i, 1); saveSettings(); renderGroups(); }
        function moveGroup(i, dir) { const ni = i + dir; if (ni < 0 || ni >= groups.length) return; const tmp = groups[i]; groups[i] = groups[ni]; groups[ni] = tmp; saveSettings(); renderGroups(); }
        function deleteWord(i, j) { groups[i].words.splice(j, 1); saveSettings(); renderGroups(); }
        function moveWord(i, j, dir) {
            const words = groups[i].words;
            const newIndex = j + dir;
            if (newIndex < 0 || newIndex >= words.length) return;
            [words[j], words[newIndex]] = [words[newIndex], words[j]];
            saveSettings();
            renderGroups();
        }
        function toggleSubgroup(i, checked) { groups[i].isSubgroup = checked; saveSettings(); renderGroups(); }

        function weightedRandom(words) {
            const pool = [];
            words.forEach(w => { for (let k = 0; k < w.weight; k++) pool.push(w.text); });
            if (pool.length === 0) return null;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function chooseCount(min, max) {
            if (min > max) [min, max] = [max, min];

            const values = [];
            const weights = [];

            for (let n = min; n <= max; n++) {
                // 0に近いほど重みを大きくするが、極端にならないように 1 / (n + 2) 程度にする
                // 以前は (S-n)^4 だったので急激すぎた
                // 例: min=0, max=1 のとき
                // n=0 -> 1/1 = 1
                // n=1 -> 1/2 = 0.5
                // -> 0が出る確率 66%, 1が出る確率 33% くらいになる
                const w = 1 / (n + 1);
                values.push(n);
                weights.push(w);
            }

            const total = weights.reduce((a, b) => a + b, 0);
            if (total === 0) return min;

            let r = Math.random() * total;
            for (let i = 0; i < values.length; i++) {
                if (r < weights[i]) return values[i];
                r -= weights[i];
            }
            return values[values.length - 1];
        }

        function parseExpr(str) {
            // 改行は無視して連結する（影響を与えない）
            str = str.replace(/[\r\n]+/g, "");
            let i = 0;
            function skip() { while (str[i] && /\s/.test(str[i])) i++; }
            function parseFactor() {
                skip();
                if (str[i] === "(") { i++; const node = parseOr(); skip(); if (str[i] !== ")") throw new Error(") expected"); i++; return node; }
                let word = "";
                while (i < str.length && ![",", "&", ")"].includes(str[i])) {
                    // 改行も単語の一部にならないように除外
                    if (/\s/.test(str[i]) && word.length > 0) {
                        // 単語後の空白はskipで飛ばされるが、word収集ループ内ではbreak扱い
                        break;
                    } else if (/\s/.test(str[i])) {
                        i++; // 単語前の空白（skipで飛ばせなかったものがあれば）
                        continue;
                    }
                    word += str[i++];
                }
                return { type: "WORD", value: word.trim() };
            }
            function parseAnd() { let nodes = [parseFactor()]; while (true) { skip(); if (str[i] === "&") { i++; nodes.push(parseFactor()); } else break; } if (nodes.length === 1) return nodes[0]; return { type: "AND", children: nodes }; }
            function parseOr() { let nodes = [parseAnd()]; while (true) { skip(); if (str[i] === ",") { i++; nodes.push(parseAnd()); } else break; } if (nodes.length === 1) return nodes[0]; return { type: "OR", children: nodes }; }
            return parseOr();
        }

        function evalExpr(node, words) {
            if (!node) return false;
            if (node.type === "WORD") return words.includes(node.value);
            if (node.type === "AND") return node.children.every(c => evalExpr(c, words));
            if (node.type === "OR") return node.children.some(c => evalExpr(c, words));
        }

        function draw() {
            const resultsDiv = document.getElementById("results"); resultsDiv.innerHTML = "";
            const normalGroups = groups.filter(g => g.enabled && !g.isSubgroup);
            const subGroups = groups.filter(g => g.enabled && g.isSubgroup);
            const finalResults = [];
            const chosenWords = [];
            const processed = new Set();

            function processGroup(name, word) {
                finalResults.push({ name, word });
                chosenWords.push(word);
                let changed = true;
                while (changed) {
                    changed = false;
                    subGroups.forEach(sg => {
                        if (processed.has(sg)) return;
                        if (!sg.triggers) return;
                        try {
                            const ast = parseExpr(sg.triggers);
                            if (evalExpr(ast, chosenWords)) {
                                const count = chooseCount(sg.min || 0, sg.max || 0);
                                const pool = [...sg.words];
                                for (let k = 0; k < count && pool.length > 0; k++) {
                                    const result = weightedRandom(pool);
                                    if (result) {
                                        finalResults.push({ name: sg.name, word: result });
                                        chosenWords.push(result);
                                        pool.splice(pool.findIndex(w => w.text === result), 1);
                                    }
                                }
                                processed.add(sg);
                                changed = true;
                            }
                        } catch (e) { console.error("Trigger parse error", e); }
                    });
                }
            }

            normalGroups.forEach(g => {
                const count = chooseCount(g.min || 0, g.max || 0);
                const pool = [...g.words];
                for (let k = 0; k < count && pool.length > 0; k++) {
                    const result = weightedRandom(pool);
                    if (result) {
                        processGroup(g.name, result);
                        pool.splice(pool.findIndex(w => w.text === result), 1);
                    }
                }
            });

            let lastGroup = null;
            finalResults.forEach(r => {
                const line = document.createElement("div"); line.className = "result-line";
                const nameSpan = document.createElement("div"); nameSpan.className = "result-name";
                nameSpan.textContent = (r.name !== lastGroup) ? r.name : "";
                lastGroup = r.name;
                line.appendChild(nameSpan);
                const wordSpan = document.createElement("div"); wordSpan.className = "result-word"; wordSpan.textContent = r.word;
                line.appendChild(wordSpan);
                resultsDiv.appendChild(line);
            });
        }

        function searchGoogle() {
            const resultsDiv = document.getElementById("results");
            const words = [];
            let currentGroup = null;
            resultsDiv.querySelectorAll(".result-line").forEach(line => {
                const word = line.querySelector(".result-word").textContent;
                const groupName = line.querySelector(".result-name").textContent;
                if (groupName) currentGroup = groups.find(g => g.name === groupName);
                if (!word || !currentGroup || !currentGroup.search) return;
                words.push(word);
            });
            if (words.length === 0) return;
            const query = encodeURIComponent(words.join(" "));
            window.open(`https://www.google.com/search?q=${query}`, "_blank");
        }

        function exportSettings() {
            const name = document.getElementById("settingsName").value;
            const data = { groups: groups, name: name };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a"); a.href = url;
            const settingsName = name.trim();
            a.download = settingsName ? `${settingsName}.json` : "settings.json";
            a.click();
            URL.revokeObjectURL(url);
        }

        function importSettings(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (Array.isArray(data)) {
                        groups = data;
                    } else {
                        groups = data.groups || [];
                        const nameBox = document.getElementById("settingsName");
                        if (nameBox) nameBox.value = data.name || "";
                    }
                    saveSettings();
                    renderGroups();
                }
                catch (err) { alert("インポートに失敗しました: " + err.message); }
            };
            reader.readAsText(file);
        }

        loadSettings(); renderGroups();
    </script>
</body>

</html>
